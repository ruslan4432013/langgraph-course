# Перемотка графа (Time Travel) в LangGraph

Данный проект является учебным примером по использованию функциональности "Time Travel" (путешествие во времени) в
LangGraph. Примеры демонстрируют, как можно просматривать историю состояний графа, возвращаться к предыдущим чекпоинтам
и создавать новые ветки выполнения.

## О проекте

В основе примера лежит простой агент-помощник, который умеет выполнять арифметические операции (сложение, умножение,
деление) с помощью инструментов (tools).

### Основные концепции:

- **Persistence (Постоянство):** Использование `MemorySaver` для сохранения состояния графа на каждом шаге.
- **State History:** Получение списка всех предыдущих состояний графа.
- **Replay (Повтор):** Возможность запустить граф заново с любого сохраненного состояния.
- **Fork (Ветвление):** Возможность изменить состояние в прошлом и запустить выполнение по новому пути.

## Структура проекта

- `src/time_travel_intro/agent.py` — Определение графа, LLM и инструментов.
- `src/time_travel_intro/time_travel_example.py` — Основной пример использования LangGraph Python API для перемещения по
  истории.
- `src/time_travel_intro/time_travel_studio_example.py` — Пример взаимодействия с LangGraph через SDK (например, при
  запущенном LangGraph Studio).
- `src/settings.py` — Настройки проекта и конфигурация LLM.
- `langgraph.json` — Конфигурация для LangGraph Studio.

## Установка и запуск

1. **Установите зависимости:**
   ```bash
   pip install -r requirements.txt
   ```

2. **Настройте переменные окружения:**
   Создайте файл `.env` на основе `.env.example` и укажите ваш `OPENAI_API_KEY`.

3. **Запустите основной пример:**
   ```bash
   python -m src.time_travel_intro.time_travel_example
   ```

## Как это работает

### Просмотр истории

С помощью `graph.get_state_history(thread)` можно получить все состояния, через которые прошел граф. Каждое состояние
содержит значения (`values`), следующий узел для выполнения (`next`) и конфигурацию с `checkpoint_id`.

### Replay (Повтор)

Вы можете запустить граф с любого момента, передав `config` старого состояния в метод `stream`:

```python
graph.stream(None, to_replay.config, stream_mode="values")
```

### Fork (Ветвление)

Чтобы изменить ход выполнения, можно обновить состояние с помощью `graph.update_state`. Если при обновлении указать `id`
существующего сообщения, оно будет заменено, что создаст новую ветку истории.

```python
graph.update_state(
    to_fork.config,
    {"messages": [HumanMessage(content='Новый запрос', id=old_id)]},
)
```
