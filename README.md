# Учебный пример: Использование Memory в LangGraph

Данный проект демонстрирует реализацию AI-агента с использованием библиотеки LangGraph, который обладает "памятью" (
сохранением состояния) между вызовами. Агент специализируется на выполнении арифметических операций и использует
инструменты для вычислений.

## Особенности примера

- **Memory (Short-term memory)**: Использование `MemorySaver` для сохранения истории сообщений в рамках потока (thread).
- **ReAct Agent**: Агент, который может использовать внешние инструменты (функции Python) для решения задач.
- **Persistence**: Благодаря `checkpointer`, агент помнит контекст предыдущих сообщений при использовании одного и того
  же `thread_id`.

## Схема графа

Ниже представлена визуализация графа состояний нашего агента:

![Схема графа](static/img.png)

## Структура проекта

- `src/main.py` — основной код приложения: определение инструментов, графа и логики работы с памятью.
- `src/settings.py` — конфигурация приложения и загрузка переменных окружения.
- `static/img.png` — графическое представление структуры графа.
- `langgraph.json` — конфигурация для LangGraph Studio.
- `requirements.txt` — список зависимостей.

## Как это работает

1. **Инструменты**: Мы определили три функции: `add`, `multiply` и `divide`.
2. **Память**: При компиляции графа подключается `MemorySaver`:
   ```python
   memory = MemorySaver()
   react_graph = builder.compile(checkpointer=memory)
   ```
3. **Контекст**: Для того чтобы агент "вспомнил" предыдущий диалог, при вызове передается конфигурация с `thread_id`:
   ```python
   config = {"configurable": {"thread_id": "1"}}
   result = react_graph.invoke({"messages": [HumanMessage(content="Сложи 3 и 4")]}, config=config)
   ```

## Запуск

1. Установите зависимости:
   ```bash
   pip install -r requirements.txt
   ```

2. Настройте переменные окружения в файле `.env` (используйте `.env.example` как шаблон):
   ```
   OPENAI_API_KEY=ваш_ключ
   ```

3. Запустите пример:
   ```bash
   python src/main.py
   ```

При запуске вы увидите, как агент сначала складывает числа, а затем, благодаря памяти, понимает, что значит "умножь *
*это** на 2", используя результат предыдущей операции.
