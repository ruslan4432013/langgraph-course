# Примеры Мульти-схем в LangGraph

Данный проект является учебным примером использования нескольких схем состояния (Multi-schemas) в LangGraph.
Использование различных схем позволяет более гибко управлять данными внутри графа, обеспечивая инкапсуляцию приватного
состояния узлов и четкое определение интерфейсов ввода-вывода.

## Содержание

- [Концепция](#концепция)
- [Установка](#установка)
- [Примеры](#примеры)
    - [Пример 1: Приватное состояние](#пример-1-приватное-состояние)
    - [Пример 2: Фильтрация входных и выходных данных](#пример-2-фильтрация-входных-и-выходных-данных)
- [Конфигурация](#конфигурация)

## Концепция

В LangGraph по умолчанию используется одна общая схема состояния (`State`). Однако в сложных сценариях полезно разделять
данные:

1. **Overall State**: Общее состояние графа, доступное всем узлам.
2. **Private State**: Внутреннее состояние конкретного узла или группы узлов, которое не должно засорять общее
   состояние.
3. **Input Schema**: Схема, определяющая, какие данные граф ожидает на вход.
4. **Output Schema**: Схема, определяющая, какие данные граф вернет после завершения работы.

## Установка

1. Клонируйте репозиторий.
2. Создайте виртуальное окружение и активируйте его.
3. Установите зависимости:

```bash
pip install -r requirements.txt
```

## Примеры

Все примеры находятся в файле `src/main.py`.

### Пример 1: Приватное состояние

В этом примере показано, как узлы могут использовать свои собственные схемы состояния, отличные от общей схемы графа.

- `OverallState` содержит только поле `foo`.
- `PrivateState` содержит поле `baz`.
- `node_1` принимает `OverallState`, но возвращает `PrivateState`.
- `node_2` принимает `PrivateState` и возвращает `OverallState`.

Это позволяет передавать данные между узлами, не объявляя все промежуточные поля в основном состоянии графа.

### Пример 2: Фильтрация входных и выходных данных

Этот пример демонстрирует, как ограничить данные, которые пользователь передает в граф, и данные, которые граф
возвращает пользователю.

- `InputState`: определяет только те поля, которые нужны для запуска.
- `OutputState`: определяет только те поля, которые получит пользователь в итоге.
- `OverallState`: содержит все внутренние поля (например, логи размышлений `notes`), которые не нужны пользователю.

*Примечание: В коде этот пример может быть закомментирован. Раскомментируйте его для тестирования.*

## Конфигурация

Проект включает файл `langgraph.json`, который позволяет
использовать [LangGraph Studio](https://github.com/langchain-ai/langgraph-studio) или `langgraph-cli` для визуализации и
отладки графа.

```json
{
  "dependencies": [
    "./requirements.txt"
  ],
  "graphs": {
    "graph": "./src/main.py:graph"
  },
  "env": "./.env"
}
```

## Запуск

Для запуска примера из терминала выполните:

```bash
python src/main.py
```
