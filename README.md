# Параллелизация в LangGraph

Этот раздел содержит примеры реализации параллельного выполнения узлов в LangGraph.

## Содержание

1. [Учебные примеры (parallelization_examples.py)](#учебные-примеры-parallelization_examplespy)
2. [Практический пример: Ассистент-исследователь (assistant_example.py)](#практический-пример-ассистент-исследователь-assistant_examplepy)

---

## Учебные примеры (`parallelization_examples.py`)

В этом файле последовательно разобраны основные концепции параллелизации и управления состоянием:

### Пример 1: Последовательное выполнение

Базовый пример, где узлы выполняются строго друг за другом: `A -> B -> C -> D`.

### Пример 2: Ошибка при параллельном выполнении

Демонстрация того, что происходит, если запустить узлы параллельно без использования редьюсера. При попытке двух узлов
одновременно обновить одно и то же поле состояния возникает `InvalidUpdateError`.

### Пример 3: Использование `operator.add`

Решение проблемы из Примера 2. Мы используем `Annotated[list, operator.add]` в определении состояния, что позволяет
LangGraph автоматически объединять результаты параллельных узлов в список.

### Пример 4: Fan-in (Схождение)

Пример того, как один узел может ожидать завершения нескольких предыдущих узлов. В данном случае узел `D` ожидает
завершения узлов `B2` и `C`.

### Пример 5: Кастомный редьюсер

Демонстрация использования собственной функции-редьюсера для специфической логики объединения данных (в данном примере —
объединение списков с автоматической сортировкой).

---

## Практический пример: Ассистент-исследователь (`assistant_example.py`)

Более сложный пример, использующий параллелизацию для ускорения сбора информации.

### Граф выполнения

![Граф ассистента](static/img.png)

### Описание работы

1. **Параллельный поиск**: Граф одновременно запускает два узла поиска:
    - `search_wikipedia`: Ищет информацию в Википедии.
    - `search_web`: Ищет информацию в сети через Tavily.
2. **Сбор данных**: Результаты обоих поисков накапливаются в поле `context` благодаря редьюсеру `operator.add`.
3. **Генерация ответа**: Узел `generate_answer` получает полный контекст и формирует итоговый ответ с помощью LLM.

Такой подход позволяет значительно сократить время ожидания ответа, так как сетевые запросы выполняются одновременно.
